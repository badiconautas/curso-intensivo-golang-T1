20 de mai. de 2025

## Intensivão Golang\!

Convidados [adolfoagnelli@gmail.com](mailto:adolfoagnelli@gmail.com) [felipeverissimo1985@gmail.com](mailto:felipeverissimo1985@gmail.com) [lucas Badico](mailto:lucas@badico.cloud) [matheusabranches17@gmail.com](mailto:matheusabranches17@gmail.com) [sarahcarbo207@gmail.com](mailto:sarahcarbo207@gmail.com)

Anexos [Intensivão Golang\!](https://www.google.com/calendar/event?eid=MzZmNGs3Yjk4N3ByZmEzMzdpczByODZoaWxfMjAyNTA1MjBUMTAwMDAwWiBsdWNhc0BiYWRpY28uY2xvdWQ) [Treinamento Golang\! - 2025/05/15 06:57 GMT-03:00 - Recording](https://drive.google.com/file/d/1cqhyakQXcmgWjVoOaRYR36-2YLCTvZq5/view?usp=drive_web) [Treinamento Golang\! - 2025/05/15 06:57 GMT-03:00 - Chat](https://drive.google.com/file/d/1bb0yNoO0YcGSDY624feLlKOru7IYjEie/view?usp=drive_web) [Treinamento Golang\! - 2025/05/15 06:57 GMT-03:00 - Anotações do Gemini](https://docs.google.com/document/d/14KeRyW_1Fp4XlCN5F9RDJYQLhlyJYP_3fh598q0sMrE/edit?usp=drive_web) 

Registros da reunião [Transcrição](?tab=t.n3i3yoctobao) [Gravação](https://drive.google.com/file/d/1QT6-6tchcJbplOU0QLaDUKTqyrnSkJ51/view?usp=drive_web) 

### Resumo

lucas Badico apresentou o sumário e a transcrição da primeira aula, além de introduzir conceitos de APIs e backends, explicando sua natureza e a importância dos sockets. Ele também demonstrou o uso do Postman para teste de APIs e iniciou a criação de um servidor básico em Go com roteamento utilizando o Gorilla Mux, incluindo a definição de rotas e a implementação da rota "ping" por adolfo agnelli, Luiz Felipe Verissimo da silva e Matheus Abranches. A aula também abordou a estruturação da aplicação com handlers, a criação de tipos e métodos em Go, a introdução ao Docker e ao banco de dados CDB, e a tentativa inicial de integração do banco de dados à aplicação, com lucas Badico explicando a visibilidade de variáveis e métodos.

### Detalhes

* **Sumário e Transcrição da Aula 1** lucas Badico informou que o sumário da aula um, gerado pelo Google Gemini, e a transcrição completa foram adicionados ao repositório ([00:00:00](?tab=t.n3i3yoctobao#heading=h.mvev96fpy396)). Ele mencionou que haverá diversos recursos no OneDrive, incluindo o sumário com a transcrição, gravações originais e editadas, para revisão. lucas Badico também indicou que o sumário e o histórico das construções ficarão no próprio projeto ([00:01:35](?tab=t.n3i3yoctobao#heading=h.zafmmimdiv34)).

* **Introdução às APIs e Backends** lucas Badico iniciou a discussão sobre APIs e bancos de dados. Ele perguntou aos participantes como eles definiriam um backend, e adolfo agnelli compartilhou a analogia do restaurante, onde o backend é a cozinha ([00:02:38](?tab=t.n3i3yoctobao#heading=h.ddsicjo3xuz0)). Luiz Felipe Verissimo da silva descreveu o backend como o servidor onde residem as regras de negócio e a conexão com o banco de dados ([00:04:18](?tab=t.n3i3yoctobao#heading=h.ti2g5v7xpba5)).

* **Natureza de um Backend e Sockets** lucas Badico explicou que um backend é essencialmente o computador de outra pessoa, e na nuvem, é uma série de servidores pertencentes a terceiros ([00:04:18](?tab=t.n3i3yoctobao#heading=h.ti2g5v7xpba5)). Ele enfatizou que um backend pode ser desenvolvido em qualquer linguagem, desde que possua um recurso crucial: um socket, que é uma forma de conexão para comunicação. lucas Badico comparou o socket a uma terceira forma de interface para interação com a máquina, além da interface gráfica e do terminal, sendo também uma forma de IO (input/output) ([00:05:29](?tab=t.n3i3yoctobao#heading=h.udk3e7p0iq8g)) ([00:07:37](?tab=t.n3i3yoctobao#heading=h.hbe6kdbziqa8)).

* **Abstração em Linguagens de Programação** lucas Badico mencionou que a comunicação via socket é fundamental para um servidor. Ele contrastou Go com outras linguagens como JavaScript e Node.js, que tendem a abstrair as complexidades de IO, enquanto Go as expõe de forma mais direta ([00:09:15](?tab=t.n3i3yoctobao#heading=h.y8xl6snbd5fx)). Essa característica de Go evita a criação excessiva de abstrações e frameworks, diferentemente do ecossistema JavaScript ([00:10:39](?tab=t.n3i3yoctobao#heading=h.qrrhg9rje9pq)).

* **Introdução ao Postman para Teste de APIs** lucas Badico apresentou o Postman como um software claro para visualizar e interagir com APIs HTTP ([00:10:39](?tab=t.n3i3yoctobao#heading=h.qrrhg9rje9pq)). Ele explicou que o Postman facilita a compreensão dos elementos necessários para uma requisição HTTP, como verbos (GET, POST, PUT, PATCH, DELETE), URL, parâmetros (queries e path parameters), headers e body. Os verbos HTTP possuem tanto uma função mecânica quanto semântica, indicando a ação a ser realizada (ex: GET para listar, POST para ação, DELETE para remoção) ([00:12:51](?tab=t.n3i3yoctobao#heading=h.jfa06aw7jegs)).

* **Headers e Body em Requisições HTTP** lucas Badico detalhou que os headers em uma requisição HTTP contêm metainformações, como autorização, autenticação e cookies. O body é o corpo da mensagem, utilizado para enviar dados para a API, frequentemente no formato JSON. Ele mencionou seu curso de Postman, onde esses conceitos são abordados detalhadamente ([00:15:49](?tab=t.n3i3yoctobao#heading=h.w1ffgrj0y9ry)).

* **Criação de um Servidor Básico em Go** lucas Badico iniciou a demonstração da criação de um servidor em Go, começando com a estrutura básica de um arquivo Go: o \`package main\` e a função \`main\` ([00:18:30](?tab=t.n3i3yoctobao#heading=h.os1u9l5b4was)). Para um "Hello World", é necessário importar o pacote \`log\` e usar a função \`log.Println\`. Ele pediu para Matheus Abranches executar o programa via terminal usando o comando \`go run main.go\` ([00:20:04](?tab=t.n3i3yoctobao#heading=h.auur6q7vn2j)) ([00:23:24](?tab=t.n3i3yoctobao#heading=h.a97o9j1xw8n7)).

* **Inicialização de Módulo Go com \`go mod init\`** lucas Badico explicou que para gerenciar dependências em Go, é necessário inicializar um módulo usando o comando \`go mod init\` seguido pelo caminho do módulo (ex: \`github.com/LucasBadico/intensivo-hello-world\`) ([00:23:24](?tab=t.n3i3yoctobao#heading=h.a97o9j1xw8n7)). Esse comando cria um arquivo \`go.mod\` que rastreia as dependências do projeto ([00:27:04](?tab=t.n3i3yoctobao#heading=h.590fvd823qr8)). Ele esclareceu que o caminho do módulo serve como identificador para o projeto, importante para importações e descoberta futura ([00:25:07](?tab=t.n3i3yoctobao#heading=h.gnyib4sjkut)).

* **Instalação do Pacote Gorilla Mux** sasa cruz executou o comando \`go get github.com/gorilla/mux@latest\` para instalar o pacote Gorilla Mux, um roteador HTTP para Go ([00:29:37](?tab=t.n3i3yoctobao#heading=h.u48d4wgp2ahr)). lucas Badico explicou que o \`go.mod\` é atualizado com a dependência e o arquivo \`go.sum\` garante que as mesmas versões das dependências sejam usadas em instalações futuras ([00:31:11](?tab=t.n3i3yoctobao#heading=h.vdoa6rmu4219)). Ele mencionou que antes do \`go mod\`, a prática comum era trazer o código das dependências para uma pasta \`vendor\` ([00:32:40](?tab=t.n3i3yoctobao#heading=h.i5z9vgbijxvy)).

* **Utilização do Gorilla Mux para Roteamento** lucas Badico demonstrou como importar e usar o pacote Gorilla Mux no arquivo \`main.go\` ([00:34:14](?tab=t.n3i3yoctobao#heading=h.me7v8zde08z5)). Ele criou um novo roteador usando \`mux.NewRouter()\` e explicou que a última parte do caminho do pacote (neste caso, \`mux\`) é usada como "holder" para acessar as funcionalidades do módulo. O roteador (\`Muxer\`) é usado para definir as rotas da API ([00:36:13](?tab=t.n3i3yoctobao#heading=h.cfk9i5t8s20r)).

* **Definição de uma Rota "Hello World" com GET** lucas Badico criou a primeira rota, definindo um handler para o caminho \`/hello\` que responde a requisições GET. Ele explicou que a função de handler recebe dois parâmetros: um \`http.ResponseWriter\` (para escrever a resposta) e um \`\*http.Request\` (para acessar os detalhes da requisição) ([00:37:44](?tab=t.n3i3yoctobao#heading=h.a1ufcokbt4wa)) ([00:40:40](?tab=t.n3i3yoctobao#heading=h.xby49spn2suj)). O roteador atua como um filtro, direcionando as requisições para os handlers apropriados ([00:39:18](?tab=t.n3i3yoctobao#heading=h.mwqzlwajs3m)). Luiz Felipe Verissimo da silva executou o servidor novamente com \`go run main.go\` ([00:42:26](?tab=t.n3i3yoctobao#heading=h.n10y03qv0d69)).

* **Teste da Rota "Hello World" e Criação da Rota "Ping" com POST** lucas Badico testou a rota \`/hello\` com um GET usando o Postman, demonstrando que ela retorna a mensagem "WRE Word" ([00:42:26](?tab=t.n3i3yoctobao#heading=h.n10y03qv0d69)). Ele também mostrou que uma requisição POST para a mesma URL não funciona, conforme esperado ([00:43:27](?tab=t.n3i3yoctobao#heading=h.xcdkaev45pnr)). Em seguida, ele desafiou os participantes a criar uma nova rota \`/ping\` que responda a requisições POST com a mensagem "pong" ([00:44:26](?tab=t.n3i3yoctobao#heading=h.86w84wadn1ns)). adolfo agnelli, com a ajuda de Luiz Felipe Verissimo da silva e Matheus Abranches, implementou a rota \`/ping\` com o método POST. sasa cruz explicou o código da nova rota, demonstrando compreensão do \`ResponseWriter\` e do método HTTP ([00:46:03](?tab=t.n3i3yoctobao#heading=h.5gwzvxyfzqmm)) ([00:48:42](?tab=t.n3i3yoctobao#heading=h.jjumdt245c71)). A semântica dos métodos HTTP (GET para leitura, POST para ação) foi discutida ([00:51:42](?tab=t.n3i3yoctobao#heading=h.ftcr8j4sxo5z)). A implementação da rota "ping" com POST foi bem-sucedida ([00:54:16](?tab=t.n3i3yoctobao#heading=h.jvvfk0vjvouf)).

* **Estruturação da Aplicação e Handlers** lucas Badico mencionou que a próxima etapa seria estruturar a aplicação de forma mais organizada, introduzindo o conceito de Handlers. Ele respondeu às perguntas de Luiz Felipe Verissimo da silva sobre hot reload (a ser abordado em semanas futuras) e a possibilidade de importar arquivos para criar routers (que seria o próximo ponto) ([00:54:16](?tab=t.n3i3yoctobao#heading=h.jvvfk0vjvouf)). Matheus Abranches confirmou seu entendimento sobre os parâmetros da função de handler (\`ResponseWriter\` e \`\*http.Request\`) ([00:55:19](?tab=t.n3i3yoctobao#heading=h.ydxha4136b55)).

* **Conceito de Handlers** lucas Badico explicou que handlers são funções responsáveis por cuidar da infraestrutura da aplicação, atuando como intermediários entre a camada externa (infra) e as camadas internas da aplicação. Comparou o handler a um garçom em um restaurante, que pega os pedidos (dados) da parte externa e os leva para a cozinha (camada interna) ([00:56:54](?tab=t.n3i3yoctobao#heading=h.hx07fb9cg8od)). O handler entende o contrato da infra, que pode ser HTTP, CLI, GRPC ou WebSocket, convertendo as requisições para a camada da aplicação ([00:58:58](?tab=t.n3i3yoctobao#heading=h.88zjyaefy3hn)).

* **Organização com Pacotes Handler** lucas Badico demonstrou que, para evitar um arquivo de handler muito grande, é comum criar um pacote chamado "handler". Ao mover as funções para este pacote, o package do arquivo muda para "handler", e para acessar essas funções, é necessário importar o pacote utilizando o caminho do módulo Go e o nome do pacote (ex: \`github.com/lupas/intensivo/handler\`) ([01:01:12](?tab=t.n3i3yoctobao#heading=h.axvzvq75y87c)). lucas Badico explicou que em Go, a visibilidade de funções e variáveis é controlada pela primeira letra do nome: maiúscula para público (exportável) e minúscula para privado (acessível apenas dentro do pacote) ([01:03:09](?tab=t.n3i3yoctobao#heading=h.mm03ehtsm1wj)).

* **Criação de Tipos e Métodos em Go** lucas Badico introduziu o conceito de criar um tipo (struct) chamado \`Handler\` para agrupar as funções (agora métodos) relacionadas ao handler. Explicou que essa prática permite compartilhar e instanciar dependências dentro do handler, como um banco de dados ([01:06:32](?tab=t.n3i3yoctobao#heading=h.enduklle02x5)). Para criar uma instância do tipo \`Handler\`, é comum definir um construtor, uma função pública chamada \`New\`, que pode receber dependências como argumentos e retornar um ponteiro para um \`Handler\` ([01:08:19](?tab=t.n3i3yoctobao#heading=h.ou3sgh29g609)).

* **Instanciação do Handler e Compartilhamento de Dependências** lucas Badico demonstrou como instanciar o handler utilizando o construtor \`handler.New()\`. Enfatizou a vantagem de ter uma única instância da conexão com o banco de dados dentro do handler, evitando múltiplas instanciações ([01:09:44](?tab=t.n3i3yoctobao#heading=h.727vj5dfs4on)). Matheus Abranches pediu para lucas Badico explicar novamente a parte da criação do tipo, o que foi feito, esclarecendo que inicialmente não há vantagem funcional, apenas semântica, assemelhando-se à criação de classes com métodos em outras linguagens, mas em Go é feito com tipos ([01:11:05](?tab=t.n3i3yoctobao#heading=h.4nwpzxm77jeu)).

* **Introdução ao Docker e ao Banco de Dados CDB** lucas Badico introduziu o Docker como uma ferramenta para criar ambientes isolados, demonstrando a criação rápida de um banco de dados CDB para desenvolvimento local ([01:13:16](?tab=t.n3i3yoctobao#heading=h.mplrfovn4jp7)). Explicou que o CDB é um banco de dados não relacional, mais fácil para começar a inserir dados rapidamente. lucas Badico mostrou como criar um "banco" (coleção) chamado "notebook" e inserir dados via API, ressaltando que ele não possui esquema ([01:15:36](?tab=t.n3i3yoctobao#heading=h.9kma9iiq16oz)).

* **Integração do Banco de Dados CDB com a Aplicação Go** lucas Badico iniciou o processo de integração do banco de dados CDB à aplicação Go, importando os pacotes \`kivic/v4\` e \`cdb/v4\`. Mostrou a instanciação de um client do CDB utilizando um pacote da comunidade (Kivic) ([01:19:58](?tab=t.n3i3yoctobao#heading=h.l0x38r7fscow)). O objetivo era injetar a dependência do client do CDB dentro do tipo \`Handler\` para que os métodos do handler pudessem interagir com o banco de dados ([01:23:51](?tab=t.n3i3yoctobao#heading=h.4dk615ro3ofp)). Houve um problema técnico ao tentar executar a integração do banco de dados, que será corrigido e continuado na próxima aula ([01:28:37](?tab=t.n3i3yoctobao#heading=h.qqzzsrdht11)).

* **Visibilidade de Variáveis e Métodos em Go** lucas Badico reforçou que a visibilidade em Go (público ou privado) é determinada pela letra inicial de identificadores (variáveis, tipos, funções, métodos, campos de structs). Identificadores que começam com letra minúscula são privados e só podem ser acessados dentro do pacote em que são definidos. Identificadores que começam com letra maiúscula são públicos e podem ser acessados de outros pacotes após a importação ([01:30:27](?tab=t.n3i3yoctobao#heading=h.cv2hlxztbnp)).

* **Próximos Passos: Ciclo Completo da Aplicação** lucas Badico resumiu a aula, mencionando a discussão sobre APIs, a anatomia de uma aplicação Go, tipagem e visibilidade ([01:28:37](?tab=t.n3i3yoctobao#heading=h.qqzzsrdht11)). Informou que na próxima aula será abordado o ciclo completo de uma aplicação: instanciar o banco de dados, utilizar o handler para interagir com o banco (criar, deletar, editar dados) ([01:32:02](?tab=t.n3i3yoctobao#heading=h.je94k5dwkygo)). lucas Badico agradeceu a participação e encerrou a aula, mencionando que irá identificar e corrigir o erro na integração do banco de dados para a próxima sessão ([01:33:18](?tab=t.n3i3yoctobao#heading=h.ufmh846mho0p)).

*Revise as anotações do Gemini para checar se estão corretas. [Confira dicas e saiba como o Gemini faz anotações](https://support.google.com/meet/answer/14754931)*

*Envie feedback sobre o uso do Gemini para criar notas [breve pesquisa.](https://google.qualtrics.com/jfe/form/SV_9vK3UZEaIQKKE7A?confid=O7rsjSyoKmeGdC6Uh9WlDxISOA8MCwMyBwiKAiAAGAMI)*